"""
Exploit Database Integration Module
Educational and Authorized Security Testing Tool
Integrates with Exploit-DB for known exploits
"""

import json
import os
import logging
from typing import Dict, List, Optional, Tuple
from datetime import datetime
import requests
from urllib.parse import urljoin


class ExploitDatabase:
    """Manages integration with Exploit-DB"""
    
    def __init__(self, config: Dict = None):
        """
        Initialize Exploit-DB integration
        
        Args:
            config: Configuration dictionary
        """
        self.config = config or {}
        self.logger = logging.getLogger(__name__)
        self.api_base = self.config.get('api_endpoint', 'https://www.exploit-db.com/api/')
        self.cache_file = "exploit_db_cache.json"
        self.exploit_cache = {}
        self.last_update = None
        
        # Load or initialize cache
        self._load_cache()
    
    def _load_cache(self) -> None:
        """Load exploit database cache from file"""
        if os.path.exists(self.cache_file):
            try:
                with open(self.cache_file, 'r') as f:
                    data = json.load(f)
                    self.exploit_cache = data.get('exploits', {})
                    self.last_update = data.get('last_update')
                    self.logger.info(f"Loaded {len(self.exploit_cache)} exploits from cache")
            except Exception as e:
                self.logger.error(f"Error loading cache: {e}")
                self._initialize_cache()
        else:
            self._initialize_cache()
    
    def _initialize_cache(self) -> None:
        """Initialize cache with known PDF exploits"""
        self.exploit_cache = {
            # Adobe Reader Exploits
            "11662": {
                "edb_id": 11662,
                "cve": "CVE-2010-0188",
                "title": "Adobe Reader 9.0, 9.1, 9.2 - LibTiff Integer Overflow Remote Code Execution",
                "type": "remote",
                "platform": "windows",
                "date": "2010-03-09",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "adobe", "buffer_overflow", "libtiff"],
                "description": "This module exploits a buffer overflow in Adobe Reader's libTiff library when processing specially crafted TIFF images embedded in PDF files.",
                "payload_encoding": "shellcode",
                "required_files": [],
                "compatibility": {
                    "adobe_reader": ["9.0", "9.1", "9.2", "9.3.2"]
                }
            },
            
            "14889": {
                "edb_id": 14889,
                "cve": "CVE-2010-2883",
                "title": "Adobe Reader 9.3.4 - CoolType SING Table 'uniqueName' Overflow",
                "type": "remote",
                "platform": "windows",
                "date": "2010-08-25",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "adobe", "stack_overflow", "cooltype"],
                "description": "This module exploits a stack-based buffer overflow in Adobe Reader's CoolType library when processing specially crafted SING tables in embedded fonts.",
                "payload_encoding": "shellcode",
                "required_files": [],
                "compatibility": {
                    "adobe_reader": ["9.0", "9.1", "9.2", "9.3.2", "9.3.3", "9.3.4"]
                }
            },
            
            "18136": {
                "edb_id": 18136,
                "cve": "CVE-2011-2462",
                "title": "Adobe Reader 8.0/9.0/10.0 - U3D CLODProgressiveMeshDeclaration Parsing Overflow",
                "type": "remote",
                "platform": "windows",
                "date": "2011-12-06",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "adobe", "memory_corruption", "u3d"],
                "description": "This module exploits a memory corruption vulnerability in Adobe Reader when parsing U3D (Universal 3D) data in PDF files.",
                "payload_encoding": "shellcode",
                "required_files": [],
                "compatibility": {
                    "adobe_reader": ["8.0", "9.0", "10.0", "10.1.1"]
                }
            },
            
            "24619": {
                "edb_id": 24619,
                "cve": "CVE-2013-0641",
                "title": "Adobe Reader 9.5.3/10.1.1/11.0.1 - JavaScript API Overflow",
                "type": "remote",
                "platform": "windows",
                "date": "2013-02-13",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "adobe", "javascript", "api"],
                "description": "This module exploits a vulnerability in the JavaScript API of Adobe Reader that allows arbitrary code execution.",
                "payload_encoding": "javascript",
                "required_files": [],
                "compatibility": {
                    "adobe_reader": ["9.5.3", "10.1.1", "11.0.1"]
                }
            },
            
            # Foxit Reader Exploits
            "45988": {
                "edb_id": 45988,
                "cve": "CVE-2018-19448",
                "title": "Foxit Reader 9.0.1.1049 - GoToE Action Type Confusion Remote Code Execution",
                "type": "remote",
                "platform": "windows",
                "date": "2018-11-20",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "foxit", "type_confusion", "gotoe"],
                "description": "This module exploits a type confusion vulnerability in Foxit Reader's GoToE action handler.",
                "payload_encoding": "shellcode",
                "required_files": [],
                "compatibility": {
                    "foxit_reader": ["9.0.1.1049"]
                }
            },
            
            # Sumatra PDF Exploits
            "44992": {
                "edb_id": 44992,
                "cve": "CVE-2018-1000141",
                "title": "SumatraPDF 3.1.2 - Use-After-Free",
                "type": "remote",
                "platform": "windows",
                "date": "2018-04-06",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "sumatra", "use_after_free"],
                "description": "This module exploits a use-after-free vulnerability in SumatraPDF when processing specially crafted PDF files.",
                "payload_encoding": "shellcode",
                "required_files": [],
                "compatibility": {
                    "sumatra_pdf": ["3.1.2"]
                }
            },
            
            # Generic PDF Exploits
            "34164": {
                "edb_id": 34164,
                "cve": None,
                "title": "PDF - JavaScript Code Execution",
                "type": "remote",
                "platform": "multiple",
                "date": "2014-07-18",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "javascript", "generic"],
                "description": "This module demonstrates JavaScript code execution in PDF documents using the app.launchURL() method.",
                "payload_encoding": "javascript",
                "required_files": [],
                "compatibility": {
                    "generic": ["multiple_pdf_readers"]
                }
            },
            
            "46333": {
                "edb_id": 46333,
                "cve": None,
                "title": "PDF - Automatic File Execution via OpenAction",
                "type": "remote",
                "platform": "windows",
                "date": "2019-02-12",
                "author": "unknown",
                "verified": True,
                "tags": ["pdf", "openaction", "file_execution"],
                "description": "This module exploits the OpenAction feature in PDF files to automatically execute files when the document is opened.",
                "payload_encoding": "embedded_file",
                "required_files": [],
                "compatibility": {
                    "adobe_reader": ["multiple_versions"]
                }
            }
        }
        
        self.last_update = datetime.now().isoformat()
        self._save_cache()
        self.logger.info(f"Initialized cache with {len(self.exploit_cache)} exploits")
    
    def _save_cache(self) -> None:
        """Save exploit cache to file"""
        try:
            data = {
                'exploits': self.exploit_cache,
                'last_update': self.last_update
            }
            with open(self.cache_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving cache: {e}")
    
    def get_exploit_by_id(self, edb_id: str) -> Optional[Dict]:
        """
        Get exploit details by EDB-ID
        
        Args:
            edb_id: Exploit-DB ID
            
        Returns:
            Exploit details dictionary or None if not found
        """
        return self.exploit_cache.get(str(edb_id))
    
    def search_exploits(self, criteria: Dict) -> List[Dict]:
        """
        Search exploits based on criteria
        
        Args:
            criteria: Search criteria dictionary
                - platform: Target platform
                - type: Exploit type
                - cve: Associated CVE
                - tags: List of tags to match
                
        Returns:
            List of matching exploits
        """
        results = []
        
        for edb_id, exploit in self.exploit_cache.items():
            match = True
            
            # Check platform
            if 'platform' in criteria:
                if criteria['platform'].lower() not in exploit.get('platform', '').lower():
                    match = False
            
            # Check type
            if 'type' in criteria:
                if criteria['type'].lower() != exploit.get('type', '').lower():
                    match = False
            
            # Check CVE
            if 'cve' in criteria:
                if exploit.get('cve') != criteria['cve']:
                    match = False
            
            # Check tags
            if 'tags' in criteria:
                if not any(tag.lower() in exploit.get('tags', []) for tag in criteria['tags']):
                    match = False
            
            if match:
                results.append({'edb_id': edb_id, **exploit})
        
        return results
    
    def get_exploits_by_cve(self, cve_id: str) -> List[Dict]:
        """
        Get all exploits for a specific CVE
        
        Args:
            cve_id: CVE identifier
            
        Returns:
            List of exploits for the CVE
        """
        return [
            {'edb_id': edb_id, **exploit}
            for edb_id, exploit in self.exploit_cache.items()
            if exploit.get('cve') == cve_id
        ]
    
    def get_exploits_for_platform(self, platform: str) -> List[Dict]:
        """
        Get all exploits for a specific platform
        
        Args:
            platform: Target platform (windows/linux/macos/multiple)
            
        Returns:
            List of platform-specific exploits
        """
        return self.search_exploits({'platform': platform})
    
    def get_best_exploit(self, platform: str, target_app: str = None) -> Optional[Dict]:
        """
        Get best exploit for given platform and target application
        
        Args:
            platform: Target platform
            target_app: Target application (e.g., adobe_reader, foxit_reader)
            
        Returns:
            Best matching exploit or None
        """
        exploits = self.get_exploits_for_platform(platform)
        
        if not exploits:
            return None
        
        # Filter by target application if specified
        if target_app:
            filtered = [
                exp for exp in exploits
                if target_app in exp.get('compatibility', {})
            ]
            if filtered:
                exploits = filtered
        
        # Sort by verification status (verified first)
        exploits.sort(key=lambda x: x.get('verified', False), reverse=True)
        
        return exploits[0] if exploits else None
    
    def list_exploits(self) -> List[Dict]:
        """List all available exploits"""
        return [
            {
                'edb_id': edb_id,
                'title': exploit['title'],
                'cve': exploit.get('cve'),
                'platform': exploit['platform'],
                'type': exploit['type'],
                'verified': exploit['verified']
            }
            for edb_id, exploit in self.exploit_cache.items()
        ]
    
    def get_exploit_stats(self) -> Dict:
        """Get statistics about exploits in cache"""
        stats = {
            'total_exploits': len(self.exploit_cache),
            'by_platform': {},
            'by_type': {},
            'by_cve': {},
            'verified_count': 0
        }
        
        for exploit in self.exploit_cache.values():
            # Count by platform
            platform = exploit.get('platform', 'unknown')
            stats['by_platform'][platform] = stats['by_platform'].get(platform, 0) + 1
            
            # Count by type
            exp_type = exploit.get('type', 'unknown')
            stats['by_type'][exp_type] = stats['by_type'].get(exp_type, 0) + 1
            
            # Count by CVE
            cve = exploit.get('cve')
            if cve:
                stats['by_cve'][cve] = stats['by_cve'].get(cve, 0) + 1
            
            # Count verified
            if exploit.get('verified', False):
                stats['verified_count'] += 1
        
        return stats
    
    def update_from_api(self) -> bool:
        """
        Update exploit cache from Exploit-DB API
        
        Returns:
            True if update successful, False otherwise
        """
        self.logger.info("API update not implemented in offline mode")
        return False
    
    def export_exploits(self, output_file: str, format: str = 'json') -> bool:
        """
        Export exploits to file
        
        Args:
            output_file: Output file path
            format: Export format (json/csv)
            
        Returns:
            True if export successful, False otherwise
        """
        try:
            if format.lower() == 'json':
                with open(output_file, 'w') as f:
                    json.dump(self.exploit_cache, f, indent=2)
            elif format.lower() == 'csv':
                import csv
                with open(output_file, 'w', newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow(['EDB-ID', 'Title', 'CVE', 'Platform', 'Type', 'Verified'])
                    for edb_id, exploit in self.exploit_cache.items():
                        writer.writerow([
                            edb_id,
                            exploit['title'],
                            exploit.get('cve', ''),
                            exploit['platform'],
                            exploit['type'],
                            exploit['verified']
                        ])
            else:
                return False
            
            self.logger.info(f"Exported {len(self.exploit_cache)} exploits to {output_file}")
            return True
        except Exception as e:
            self.logger.error(f"Error exporting exploits: {e}")
            return False
    
    def get_compatible_exploits(self, target_software: str, version: str = None) -> List[Dict]:
        """
        Get exploits compatible with specific software version
        
        Args:
            target_software: Target software (e.g., adobe_reader)
            version: Software version (optional)
            
        Returns:
            List of compatible exploits
        """
        results = []
        
        for edb_id, exploit in self.exploit_cache.items():
            compatibility = exploit.get('compatibility', {})
            
            if target_software in compatibility:
                if version:
                    if version in compatibility[target_software]:
                        results.append({'edb_id': edb_id, **exploit})
                else:
                    results.append({'edb_id': edb_id, **exploit})
        
        return results